{% extends "base.html" %}
{% block title %}{{ title }}{% endblock %}
{% block nav_console %}active{% endblock %}
{% block page_title %}Dev Console{% endblock %}
{% block content %}
<div class="row">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        <h3 class="card-title"><i class="ti ti-terminal me-2"></i>SQL Query Editor</h3>
      </div>
      <div class="card-body">
        <div class="mb-3">
          <label for="query-editor" class="form-label">
            SQL Query
            <span class="text-muted ms-2">(supports psql meta-commands like \l, \dt, \d tablename)</span>
          </label>
          <textarea
            id="query-editor"
            class="form-control font-monospace"
            rows="10"
            placeholder="SELECT * FROM users;&#10;&#10;or use psql commands:&#10;\l         -- list databases&#10;\dt        -- list tables&#10;\d table   -- describe table"
            style="font-size: 14px; line-height: 1.5;"
          ></textarea>
          <div class="form-text">
            <strong>Shortcuts:</strong>
            <kbd>Ctrl</kbd>+<kbd>Enter</kbd> Execute |
            <kbd>Ctrl</kbd>+<kbd>↑</kbd> Previous query |
            <kbd>Ctrl</kbd>+<kbd>↓</kbd> Next query
          </div>
        </div>

        <div class="d-flex align-items-center gap-2">
          <button id="execute-btn" class="btn btn-primary" onclick="executeQuery()">
            <i class="ti ti-player-play me-1"></i>
            Execute
          </button>
          <button class="btn btn-ghost-secondary" onclick="clearEditor()">
            <i class="ti ti-eraser me-1"></i>
            Clear
          </button>
          <div class="form-check ms-3">
            <input class="form-check-input" type="checkbox" id="read-only-mode" checked>
            <label class="form-check-label" for="read-only-mode">
              <i class="ti ti-lock me-1"></i>
              Read-only mode
            </label>
          </div>
          <button class="btn btn-ghost-secondary ms-auto" onclick="toggleHistory()">
            <i class="ti ti-history me-1"></i>
            History
          </button>
        </div>
      </div>
    </div>

    <!-- History Panel (hidden by default) -->
    <div class="card mt-3" id="history-panel" style="display: none;">
      <div class="card-header">
        <h3 class="card-title">
          <i class="ti ti-history me-2"></i>
          Query History
        </h3>
        <div class="card-actions">
          <button class="btn btn-sm btn-ghost-danger" onclick="clearHistory()">
            <i class="ti ti-trash"></i>
            Clear All
          </button>
        </div>
      </div>
      <div class="card-body p-0">
        <div class="table-responsive">
          <table class="table table-vcenter card-table table-hover">
            <thead>
              <tr>
                <th style="width: 140px;">Time</th>
                <th>Query</th>
                <th style="width: 80px;">Status</th>
                <th style="width: 100px;">Duration</th>
                <th style="width: 80px;"></th>
              </tr>
            </thead>
            <tbody id="history-table-body">
              <tr>
                <td colspan="5" class="text-center text-muted py-4">
                  No queries in history yet
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="row mt-3" id="output-section" style="display: none;">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        <div class="d-flex justify-content-between align-items-center">
          <h3 class="card-title">
            <i class="ti ti-terminal-2 me-2"></i>
            Output
          </h3>
          <div class="d-flex gap-2">
            <button class="btn btn-sm btn-ghost-secondary" onclick="copyOutput()" id="copy-output-btn">
              <i class="ti ti-copy"></i>
            </button>
            <button class="btn btn-sm btn-ghost-secondary" onclick="clearOutput()">
              <i class="ti ti-trash"></i>
            </button>
          </div>
        </div>
      </div>
      <div class="card-body p-0">
        <div class="terminal">
          <div class="terminal-header">
            <span id="terminal-status">Ready</span>
            <span id="terminal-duration" class="ms-3"></span>
          </div>
          <div class="terminal-body" id="terminal-output"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
.terminal {
  background: #1e1e1e;
  color: #d4d4d4;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;
  font-size: 13px;
  border-radius: 0 0 8px 8px;
}

.terminal-header {
  background: #2d2d2d;
  padding: 8px 16px;
  border-bottom: 1px solid #3e3e3e;
  font-size: 12px;
  color: #858585;
}

.terminal-body {
  padding: 16px;
  max-height: 600px;
  overflow-y: auto;
  overflow-x: auto;
  white-space: pre;
  line-height: 1.5;
}

.terminal-body::-webkit-scrollbar {
  width: 12px;
  height: 12px;
}

.terminal-body::-webkit-scrollbar-track {
  background: #1e1e1e;
}

.terminal-body::-webkit-scrollbar-thumb {
  background: #424242;
  border-radius: 6px;
}

.terminal-body::-webkit-scrollbar-thumb:hover {
  background: #4e4e4e;
}
</style>

<script>
const basePath = '{{ ctx.base_path }}';
let eventSource = null;
let jobId = null;
let startTime = null;
let durationInterval = null;
const USE_LOCAL_STORAGE = {{ use_local_storage|lower }};
const ENDPOINT_ID = {{ endpoint_id }};
const HISTORY_KEY = `postgres_explorer_query_history_${ENDPOINT_ID}`;
const MAX_HISTORY = 50;

// Load history on page load
document.addEventListener('DOMContentLoaded', function() {
  loadHistory();
});

// Ctrl+Enter to execute
document.getElementById('query-editor').addEventListener('keydown', function(e) {
  if (e.ctrlKey && e.key === 'Enter') {
    e.preventDefault();
    executeQuery();
  }
  // Arrow up/down for history navigation
  if (e.key === 'ArrowUp' && e.ctrlKey) {
    e.preventDefault();
    loadPreviousQuery();
  }
  if (e.key === 'ArrowDown' && e.ctrlKey) {
    e.preventDefault();
    loadNextQuery();
  }
});

let historyIndex = -1;
let currentQuery = '';
let cachedHistory = null;

async function loadPreviousQuery() {
  if (!cachedHistory) {
    cachedHistory = await getHistory();
  }
  const history = cachedHistory;
  if (history.length === 0) return;

  if (historyIndex === -1) {
    currentQuery = document.getElementById('query-editor').value;
    historyIndex = history.length - 1;
  } else if (historyIndex > 0) {
    historyIndex--;
  }

  document.getElementById('query-editor').value = history[historyIndex].query;
}

async function loadNextQuery() {
  if (!cachedHistory) {
    cachedHistory = await getHistory();
  }
  const history = cachedHistory;
  if (historyIndex === -1) return;

  if (historyIndex < history.length - 1) {
    historyIndex++;
    document.getElementById('query-editor').value = history[historyIndex].query;
  } else {
    historyIndex = -1;
    document.getElementById('query-editor').value = currentQuery;
  }
}

async function executeQuery() {
  const query = document.getElementById('query-editor').value.trim();
  if (!query) {
    alert('Please enter a query');
    return;
  }

  const readOnly = document.getElementById('read-only-mode').checked;

  // Check if query is destructive
  try {
    const checkUrl = basePath === '/' ? '/dev/check' : `${basePath}/dev/check`;
    const checkResponse = await fetch(checkUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query, read_only: readOnly })
    });

    if (checkResponse.ok) {
      const destructiveCheck = await checkResponse.json();

      if (destructiveCheck.is_destructive) {
        if (!destructiveCheck.requires_confirmation) {
          // Destructive commands are disabled
          alert(`⛔ Destructive command detected: ${destructiveCheck.command_type}\n\nThis command is disabled. Start the server with --enable-destructive-commands to allow.`);
          return;
        }

        // Show confirmation dialog
        const confirmed = await showDestructiveConfirmation(query, destructiveCheck.command_type);
        if (!confirmed) {
          return; // User cancelled
        }
      }
    }
  } catch (error) {
    console.error('Failed to check destructive query:', error);
    // Continue anyway if check fails
  }
  const executeBtn = document.getElementById('execute-btn');

  executeBtn.disabled = true;
  executeBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Executing...';

  // Show output section
  document.getElementById('output-section').style.display = 'block';
  document.getElementById('terminal-output').textContent = '';
  document.getElementById('terminal-status').textContent = 'Running...';
  document.getElementById('terminal-duration').textContent = '';

  startTime = Date.now();
  durationInterval = setInterval(updateDuration, 100);

  try {
    const url = basePath === '/' ? '/dev/execute' : `${basePath}/dev/execute`;
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query, read_only: readOnly })
    });

    if (!response.ok) {
      const error = await response.text();
      appendOutput(`❌ Error: ${error}\n`);
      finishExecution(false);
      return;
    }

    const data = await response.json();
    jobId = data.job_id;

    // Start SSE stream
    const sseUrl = basePath === '/' ? `/dev/${jobId}/logs` : `${basePath}/dev/${jobId}/logs`;
    eventSource = new EventSource(sseUrl);

    eventSource.onmessage = function(event) {
      if (event.data) {
        appendOutput(event.data + '\n');
      }
    };

    eventSource.onerror = function() {
      eventSource.close();
      finishExecution(true);
    };

  } catch (error) {
    appendOutput(`❌ Network error: ${error.message}\n`);
    finishExecution(false);
  }
}

function appendOutput(text) {
  const output = document.getElementById('terminal-output');
  output.textContent += text;
  output.scrollTop = output.scrollHeight;
}

function updateDuration() {
  if (startTime) {
    const elapsed = ((Date.now() - startTime) / 1000).toFixed(2);
    document.getElementById('terminal-duration').textContent = `${elapsed}s`;
  }
}

function finishExecution(success) {
  const executeBtn = document.getElementById('execute-btn');
  executeBtn.disabled = false;
  executeBtn.innerHTML = '<i class="ti ti-player-play me-1"></i>Execute';

  if (durationInterval) {
    clearInterval(durationInterval);
    durationInterval = null;
  }

  const duration = startTime ? ((Date.now() - startTime) / 1000).toFixed(2) : null;
  document.getElementById('terminal-status').textContent = success ? 'Completed' : 'Failed';

  // Save to history
  const query = document.getElementById('query-editor').value.trim();
  if (query) {
    saveToHistory(query, success ? 'success' : 'failed', duration);
  }

  // Reset history navigation and cache
  historyIndex = -1;
  currentQuery = '';
  cachedHistory = null; // Invalidate cache
}

function clearEditor() {
  document.getElementById('query-editor').value = '';
}

function clearOutput() {
  document.getElementById('terminal-output').textContent = '';
  document.getElementById('output-section').style.display = 'none';
}

function copyOutput() {
  const text = document.getElementById('terminal-output').textContent;
  const btn = document.getElementById('copy-output-btn');

  navigator.clipboard.writeText(text)
    .then(() => {
      showTooltip(btn, 'Copied! ✓', 'success');
    })
    .catch(() => {
      showTooltip(btn, 'Copy failed ✗', 'danger');
    });
}

function showTooltip(element, message, type) {
  // Create tooltip
  const tooltip = document.createElement('div');
  tooltip.className = `tooltip bs-tooltip-bottom show`;
  tooltip.innerHTML = `
    <div class="tooltip-arrow"></div>
    <div class="tooltip-inner bg-${type}">${message}</div>
  `;

  // Position tooltip
  const rect = element.getBoundingClientRect();
  tooltip.style.position = 'fixed';
  tooltip.style.left = `${rect.left + rect.width / 2}px`;
  tooltip.style.top = `${rect.bottom + 5}px`;
  tooltip.style.transform = 'translateX(-50%)';
  tooltip.style.zIndex = '9999';

  document.body.appendChild(tooltip);

  // Remove after 2 seconds
  setTimeout(() => {
    tooltip.remove();
  }, 2000);
}

async function showDestructiveConfirmation(query, commandType) {
  return new Promise((resolve) => {
    const modal = document.createElement('div');
    modal.className = 'modal modal-blur fade';
    modal.innerHTML = `
      <div class="modal-dialog modal-dialog-centered" role="document">
        <div class="modal-content">
          <div class="modal-header bg-red-lt">
            <h5 class="modal-title">
              <i class="ti ti-alert-triangle me-2"></i>
              Destructive Operation Warning
            </h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
          </div>
          <div class="modal-body">
            <div class="alert alert-danger mb-3">
              <strong>⚠️ WARNING:</strong> You are about to execute a <strong>${commandType}</strong> command.
            </div>
            <p class="mb-2">Query:</p>
            <pre class="bg-dark text-white p-3 rounded" style="max-height: 200px; overflow: auto;">${escapeHtml(query)}</pre>
            <p class="text-muted mt-3">
              This operation may <strong>permanently delete or modify data</strong>.
              Are you absolutely sure you want to continue?
            </p>
            <div class="mb-3">
              <label class="form-label">Type <code>CONFIRM</code> to proceed:</label>
              <input type="text" id="confirm-input" class="form-control" placeholder="CONFIRM" autocomplete="off">
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
            <button type="button" id="confirm-btn" class="btn btn-danger" disabled>
              Execute Anyway
            </button>
          </div>
        </div>
      </div>
    `;

    document.body.appendChild(modal);
    const bsModal = new bootstrap.Modal(modal);
    bsModal.show();

    const confirmInput = modal.querySelector('#confirm-input');
    const confirmBtn = modal.querySelector('#confirm-btn');

    confirmInput.addEventListener('input', () => {
      confirmBtn.disabled = confirmInput.value !== 'CONFIRM';
    });

    confirmBtn.addEventListener('click', () => {
      bsModal.hide();
      resolve(true);
    });

    modal.addEventListener('hidden.bs.modal', () => {
      document.body.removeChild(modal);
      if (confirmInput.value !== 'CONFIRM') {
        resolve(false);
      }
    });

    // Focus input
    modal.addEventListener('shown.bs.modal', () => {
      confirmInput.focus();
    });
  });
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// History management functions
async function getHistory() {
  if (USE_LOCAL_STORAGE) {
    // Stateless mode: use localStorage
    try {
      const data = localStorage.getItem(HISTORY_KEY);
      return data ? JSON.parse(data) : [];
    } catch (e) {
      console.error('Failed to load history:', e);
      return [];
    }
  } else {
    // Normal mode: fetch from API
    try {
      const url = basePath === '/' ? '/dev/history' : `${basePath}/dev/history`;
      const response = await fetch(url);
      if (!response.ok) return [];
      const data = await response.json();
      // Convert API format to UI format
      return data.history.map(h => ({
        timestamp: h.executed_at,
        query: h.query_text,
        status: h.status,
        duration: h.duration_ms ? (h.duration_ms / 1000).toFixed(2) : null
      }));
    } catch (e) {
      console.error('Failed to load history from API:', e);
      return [];
    }
  }
}

async function saveToHistory(query, status, duration) {
  if (USE_LOCAL_STORAGE) {
    // Stateless mode: save to localStorage
    try {
      const history = await getHistory();
      const entry = {
        timestamp: new Date().toISOString(),
        query: query,
        status: status,
        duration: duration
      };

      history.push(entry);

      // Keep only last MAX_HISTORY entries
      if (history.length > MAX_HISTORY) {
        history.shift();
      }

      localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
      loadHistory(); // Refresh UI
    } catch (e) {
      console.error('Failed to save history:', e);
    }
  } else {
    // Normal mode: save to API
    try {
      const url = basePath === '/' ? '/dev/history' : `${basePath}/dev/history`;
      const duration_ms = duration ? Math.round(parseFloat(duration) * 1000) : null;
      await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          query: query,
          status: status,
          duration_ms: duration_ms
        })
      });
      loadHistory(); // Refresh UI
    } catch (e) {
      console.error('Failed to save history to API:', e);
    }
  }
}

async function loadHistory() {
  const history = await getHistory();
  const tbody = document.getElementById('history-table-body');

  if (history.length === 0) {
    tbody.innerHTML = `
      <tr>
        <td colspan="5" class="text-center text-muted py-4">
          No queries in history yet
        </td>
      </tr>
    `;
    return;
  }

  const reversed = [...history].reverse();
  tbody.innerHTML = reversed.map((entry, idx) => {
    const time = new Date(entry.timestamp).toLocaleTimeString();
    const preview = entry.query.substring(0, 100) + (entry.query.length > 100 ? '...' : '');
    const statusBadge = entry.status === 'success'
      ? '<span class="badge bg-green">Success</span>'
      : '<span class="badge bg-red">Failed</span>';
    const durationText = entry.duration ? `${entry.duration}s` : '-';

    return `
      <tr>
        <td class="text-muted">${time}</td>
        <td>
          <div class="font-monospace text-truncate" style="max-width: 400px;" title="${escapeHtml(entry.query)}">
            ${escapeHtml(preview)}
          </div>
        </td>
        <td>${statusBadge}</td>
        <td class="text-muted">${durationText}</td>
        <td>
          <button class="btn btn-sm btn-ghost-primary" onclick="loadQueryFromHistory(${history.length - 1 - idx})" title="Load query">
            <i class="ti ti-arrow-up"></i>
          </button>
        </td>
      </tr>
    `;
  }).join('');
}

async function loadQueryFromHistory(index) {
  const history = await getHistory();
  if (history[index]) {
    document.getElementById('query-editor').value = history[index].query;
    document.getElementById('query-editor').focus();
    // Optionally scroll to top
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }
}

function toggleHistory() {
  const panel = document.getElementById('history-panel');
  if (panel.style.display === 'none') {
    panel.style.display = 'block';
    loadHistory(); // Refresh
  } else {
    panel.style.display = 'none';
  }
}

async function clearHistory() {
  if (!confirm('Are you sure you want to clear all query history?')) {
    return;
  }

  if (USE_LOCAL_STORAGE) {
    // Stateless mode: clear localStorage
    localStorage.removeItem(HISTORY_KEY);
    loadHistory();
  } else {
    // Normal mode: call API
    try {
      const url = basePath === '/' ? '/dev/history' : `${basePath}/dev/history`;
      await fetch(url, { method: 'DELETE' });
      loadHistory();
    } catch (e) {
      console.error('Failed to clear history:', e);
      alert('Failed to clear history');
    }
  }
}
</script>
{% endblock %}
